!!ARBfp1.0
#
# Fragment program used for rendering GLVector instances, where
# the vector orientation is represented by a combination of RGB colours.
#
# This fragment program does the following:
# 
#  - Retrieves the voxel coordinates corresponding to the fragment
# 
#  - Uses those voxel coordinates to look up the corresponding xyz
#    directions value in the 3D RGB image texture.
#
#  - Looks up the colours corresponding to those xyz directions.
#
#  - Modulates those colours by the modulation texture.
#
#  - Uses those voxel values to colour the fragment.
#
# Required inputs:
# 
#   fragment.texcoord[0] - Fragment texture coordinates
#   fragment.texcoord[1] - Fragment voxel coordinates 
#
#   program.local[0]
#   program.local[1]
#   program.local[2]
#   program.local[3] - Transformation matrix which transforms the vector
#                      image voxel values from their texture value
#                      to the original data range.
#
#   program.local[4]
#   program.local[5]
#   program.local[6]
#   program.local[7] - Transformation matrix which transforms the vector
#                      image voxel values from their texture value
#                      to the original data range. 
#
#   program.local[8] - Image shape - number of voxels along the xyz
#                      dimensions in the image
#
#   program.local[9] - Modulation threshold (x component) - if the 
#                      modulation value is less than this, the fragment
#                      is set to fully transparent.
#
# Outputs:
#
#   result.color     - The fragment colour (written by briconalpha.prog)
#
# Author: Paul McCarthy <pauldmccarthy@gmail.com>
#

TEMP  voxCoord;
TEMP  modValue;
TEMP  voxValue;
TEMP  xColour;
TEMP  yColour;
TEMP  zColour;
TEMP  fragColour;
PARAM voxValXform[4] = { program.local[0],
                         program.local[1],
                         program.local[2],
                         program.local[3] };
PARAM cmapXform[4]   = { program.local[4],
                         program.local[5],
                         program.local[6],
                         program.local[7] };
                         
PARAM imageShape     =   program.local[8];
PARAM modThres       =   program.local[9];

# retrieve the voxel coordinates 
MOV voxCoord, fragment.texcoord[1];

# Bail if the voxel coordinate
# is out of the image space
#pragma include test_in_bounds.prog

# look up vector values
# from the 3D RGB texture
TEX voxValue, fragment.texcoord[0], texture[0], 3D;

# Look up the modulation value
# from the modulation texture
TEX modValue, fragment.texcoord[0], texture[1], 3D;

# Transform vector values from their normalised 
# texture range to their original data range,
# and take the absolue value
MAD voxValue, voxValue, voxValXform[0].x, voxValXform[3].x;
ABS voxValue, voxValue;
MAD voxValue, voxValue, cmapXform[  0].x, cmapXform[  3].x;

# Apply the modulation value
MUL voxValue, voxValue, modValue.x;

# Use the vector values to look up the
# colours for each xyz direction
TEX xColour, voxValue.x, texture[2], 1D;
TEX yColour, voxValue.y, texture[3], 1D;
TEX zColour, voxValue.z, texture[4], 1D;

# Cumulatively combine the rgb
# channels of those three colours
MOV fragColour,             xColour;
ADD fragColour, fragColour, yColour;
ADD fragColour, fragColour, zColour;

# Take the highest alpha of the three colour maps
MAX fragColour.a, xColour.a,    yColour.a;
MAX fragColour.a, fragColour.a, zColour.a;

# Clear the fragment if the modulation
# vaue does not meet the threshold
MOV modValue,   modValue.x;
SUB modValue,   modValue, modThres.x;
CMP fragColour, modValue.x, { 0, 0, 0, 0 }, fragColour;

# Colour the pixel!
MOV result.color, fragColour;

END

