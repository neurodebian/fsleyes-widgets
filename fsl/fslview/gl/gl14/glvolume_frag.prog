!!ARBfp1.0
#
# Fragment program used for rendering GLVolume instances.
#
# This fragment program does the following:
# 
#  - Retrieves the display space/voxel coordinates corresponding to the
#    fragment
# 
#  - Uses those voxel coordinates to look up the corresponding voxel
#    value in the 3D image texture.
# 
#  - Uses that voxel value to look up the corresponding colour in the
#    1D colour map texture.
# 
#  - Sets the fragment colour.
#
# Required inputs:
#
#   fragment.texcoord[0] - Fragment position in the display coordinate system
#   fragment.texcoord[1] - Fragment position in the image voxel coordinate
#                          system
#
#   program.local[0]  
#   program.local[1]
#   program.local[2]
#   program.local[3]     - Matrix which transforms voxel values into the range
#                          [0, 1], for use as a colour map texture coordinate
#
#   program.local[4]     - Image shape - number of voxels along the xyz
#                          dimensions in the image
#   program.local[5]     - Inverse of image shape
#
# Outputs:
#
#   result.color         - The fragment colour
#
# Author: Paul McCarthy <pauldmccarthy@gmail.com>
#

TEMP  voxCoord;
TEMP  normVoxCoord;
TEMP  voxValue;
TEMP  voxColour;
PARAM imageShape    = program.local[4];
PARAM imageShapeInv = program.local[5];

# This matrix scales the voxel value to
# lie in a range which is appropriate to
# the current display range 
PARAM voxValXform[4] = { program.local[0],
                         program.local[1],
                         program.local[2],
                         program.local[3] };

# retrieve the voxel coordinates,
# which should have been calculated
# by the vertex progarm
MOV voxCoord, fragment.texcoord[1];

# Normalise voxel coordinates to 
# lie in the range (0, 1), so they 
# can be used for texture lookup
MUL normVoxCoord, voxCoord, imageShapeInv;

# look up image voxel value
# from 3D image texture
TEX voxValue, normVoxCoord, texture[0], 3D;

# Scale voxel value according
# to the current display range
MUL voxValue, voxValue, voxValXform[0].x;
ADD voxValue, voxValue, voxValXform[0].w;

# look up the appropriate colour
# in the 1D colour map texture
TEX voxColour, voxValue.x, texture[1], 1D;

# If any of the voxel coordinates are
# less than 0, clear the voxel colour
CMP voxColour.w, voxCoord.x, 0.0, voxColour.w;
CMP voxColour.w, voxCoord.y, 0.0, voxColour.w;
CMP voxColour.w, voxCoord.z, 0.0, voxColour.w;

# If any voxel coordinates are greater than
# the image shape, clear the voxel colour
SUB voxCoord, voxCoord, imageShape;
CMP voxColour.w, voxCoord.x, voxColour.w, 0.0;
CMP voxColour.w, voxCoord.y, voxColour.w, 0.0;
CMP voxColour.w, voxCoord.z, voxColour.w, 0.0;

# Colour the pixel!
MOV result.color, voxColour;

END
