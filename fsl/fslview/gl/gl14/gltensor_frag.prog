!!ARBfp1.0
#
# Fragment program used for rendering GLTensor instances, where
# the tensor direction is represented by a combination of RGB colours.
#
# This fragment program does the following:
# 
#  1. Retrieves the texture coordinates corresponding to the fragment
# 
#  2. Transforms those coordinates into voxel coordinates
# 
#  3. Uses those voxel coordinates to look up the corresponding xyz
#     directions value in the 3D RGB image texture.
#
#  4. Looks up the colours corresponding to those xyz directions.
#
#  5. Modulates those colours by the modulation texture.
#
#  6. Uses those voxel values to colour the fragment.
#
# Author: Paul McCarthy <pauldmccarthy@gmail.com>
#

TEMP  dispTexCoord;
TEMP  voxTexCoord;
TEMP  normVoxTexCoord;
TEMP  modValue;
TEMP  voxValue;
TEMP  xColour;
TEMP  yColour;
TEMP  zColour;
TEMP  voxColour;
PARAM imageShape    = program.local[0];
PARAM imageShapeInv = program.local[1];

# This matrix transforms coordinates
# from the display coordinate system
# to image voxel coordinates
PARAM dispToVoxMat[4] = { state.matrix.texture[0] };

# retrieve the 3D texture coordinates
# (which are in terms of the display
# coordinate system)
MOV dispTexCoord, fragment.texcoord[0];

# Transform said coordinates
# into voxel coordinates
DP4 voxTexCoord.x, dispToVoxMat[0], dispTexCoord;
DP4 voxTexCoord.y, dispToVoxMat[1], dispTexCoord;
DP4 voxTexCoord.z, dispToVoxMat[2], dispTexCoord;

# Offset voxel coordinates by 0.5 
# so they are centred within a voxel
ADD voxTexCoord, voxTexCoord, { 0.5, 0.5, 0.5, 0.0 };

# Normalise voxel coordinates to 
# lie in the range (0, 1), so they 
# can be used for texture lookup
MUL normVoxTexCoord, voxTexCoord, imageShapeInv;

# look up tensor values
# from the 3D RGB texture
TEX voxValue, normVoxTexCoord, texture[0], 3D;
ADD voxValue, voxValue, { 0.0, 0.0, 0.0, 1.0 };

# Look up the modulation value
# from the modulation texture
TEX modValue, normVoxTexCoord, texture[1], 3D;
ADD voxValue, voxValue, { 0.0, 0.0, 0.0, 1.0 };  
  
# Use those values to look up
# the colours for each xyz
# direction
TEX xColour, voxValue.x, texture[2], 1D;
TEX yColour, voxValue.y, texture[3], 1D;
TEX zColour, voxValue.z, texture[4], 1D;

# Cumulatively combine the rgb
# channels of those three colours
MOV voxColour,            xColour;
ADD voxColour, voxColour, yColour;
ADD voxColour, voxColour, zColour;

# But take the average of the alpha channel
MUL voxColour, voxColour, { 1.0, 1.0, 1.0, 0.333333 };

# Apply the modulation factor
MUL voxColour, voxColour, modValue ;
  
# If any of the voxel coordinates are
# less than 0, clear the voxel colour
CMP voxColour.w, voxTexCoord.x, 0.0, voxColour.w;
CMP voxColour.w, voxTexCoord.y, 0.0, voxColour.w;
CMP voxColour.w, voxTexCoord.z, 0.0, voxColour.w;

# If any voxel coordinates are greater than
# the image shape, clear the voxel colour
SUB voxTexCoord, voxTexCoord, imageShape;
  
CMP voxColour.w, voxTexCoord.x, voxColour.w, 0.0;
CMP voxColour.w, voxTexCoord.y, voxColour.w, 0.0;
CMP voxColour.w, voxTexCoord.z, voxColour.w, 0.0;

# Colour the pixel!
MOV result.color, voxColour;

END
