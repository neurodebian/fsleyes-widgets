!!ARBfp1.0
#
# Fragment program used for rendering GLTensor instances, where
# the tensor direction is represented by a combination of RGB colours.
#
# This fragment program does the following:
# 
#  - Retrieves the voxel coordinates corresponding to the fragment
# 
#  - Uses those voxel coordinates to look up the corresponding xyz
#    directions value in the 3D RGB image texture.
#
#  - Looks up the colours corresponding to those xyz directions.
#
#  - Modulates those colours by the modulation texture.
#
#  - Uses those voxel values to colour the fragment.
#
# Required inputs:
#
#   program.local[0] - Image shape - number of voxels along the xyz
#                      dimensions in the image
#   program.local[1] - Inverse of image shape
#
# Outputs:
#
#   result.color - The fragment colour
#
# Author: Paul McCarthy <pauldmccarthy@gmail.com>
#

TEMP  voxCoord;
TEMP  normVoxCoord;
TEMP  modValue;
TEMP  voxValue;
TEMP  xColour;
TEMP  yColour;
TEMP  zColour;
TEMP  voxColour;
PARAM imageShape    = program.local[0];
PARAM imageShapeInv = program.local[1];

# retrieve the voxel coordinates
MOV voxCoord, fragment.texcoord[1];

# Normalise voxel coordinates to 
# lie in the range (0, 1), so they 
# can be used for texture lookup
MUL normVoxCoord, voxCoord, imageShapeInv;

# look up tensor values
# from the 3D RGB texture
TEX voxValue, normVoxCoord, texture[0], 3D;
ADD voxValue, voxValue, { 0.0, 0.0, 0.0, 1.0 };

# Look up the modulation value
# from the modulation texture -
# initialise modValue transparency
# to 1.0, so it doesn't corrupt
# our voxel colour value later on
MOV modValue, { 0.0, 0.0, 0.0, 1.0 };  
TEX modValue, normVoxCoord, texture[1], 3D;
  
# Use those values to look up the
# colours for each xyz direction
TEX xColour, voxValue.x, texture[2], 1D;
TEX yColour, voxValue.y, texture[3], 1D;
TEX zColour, voxValue.z, texture[4], 1D;

# Cumulatively combine the rgb
# channels of those three colours
MOV voxColour,            xColour;
ADD voxColour, voxColour, yColour;
ADD voxColour, voxColour, zColour;

# Take the average of the alpha channel
MUL voxColour, voxColour, { 1.0, 1.0, 1.0, 0.333333 };

# Apply the modulation factor
MUL voxColour, voxColour, modValue ;

# If any of the voxel coordinates are
# less than 0, clear the voxel colour
CMP voxColour.w, voxCoord.x, 0.0, voxColour.w;
CMP voxColour.w, voxCoord.y, 0.0, voxColour.w;
CMP voxColour.w, voxCoord.z, 0.0, voxColour.w;

# If any voxel coordinates are greater than
# the image shape, clear the voxel colour
SUB voxCoord, voxCoord, imageShape;
  
CMP voxColour.w, voxCoord.x, voxColour.w, 0.0;
CMP voxColour.w, voxCoord.y, voxColour.w, 0.0;
CMP voxColour.w, voxCoord.z, voxColour.w, 0.0;

# Colour the pixel!
MOV result.color, voxColour;

END
