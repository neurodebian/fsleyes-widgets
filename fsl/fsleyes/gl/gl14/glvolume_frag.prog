!!ARBfp1.0
#
# Fragment program used for rendering GLVolume instances.
#
# This fragment program does the following:
# 
#  - Retrieves the display space/voxel coordinates corresponding to the
#    fragment
# 
#  - Uses those voxel coordinates to look up the corresponding voxel
#    value in the 3D image texture.
# 
#  - Uses that voxel value to look up the corresponding colour in the
#    1D colour map texture.
# 
#  - Sets the fragment colour.
#
# Required inputs:
#
#   fragment.texcoord[0] - Fragment texture coordinates
#   fragment.texcoord[1] - Fragment voxel coordinates 
#
#   program.local[0]  
#   program.local[1]
#   program.local[2]
#   program.local[3]     - Matrix which transforms voxel values into the range
#                          [0, 1], for use as a colour map texture coordinate
#
#   program.local[4]     - Image shape - number of voxels along the xyz
#                          dimensions in the image
# 
#   program.local[5]     - Vector containing clipping values - voxels with a
#                          value below the low threshold (x), or above the
#                          high threshold (y) will not be shown. The (z)
#                          component determines the clipping direction - pass
#                          in -1 for the above behaviour, or +1 to invert
#                          this behaviour (i.e. to clip values that are within
#                          the range). Clipping values are assumed to be
#                          normalised to the image texture value range.
#
#   program.local[6]     - Negative colour map control. The (x) component
#                          is a boolean flag controlling whether the negative
#                          colour map is used. The (y) component is the display
#                          range centre (the value above which the regular 
#                          colour map is used, and below which the negative
#                          colour map is used), as a voxel value, normalised to
#                          the image texture value range.
#  
# Outputs:
#
#   result.color         - The fragment colour
#
# Author: Paul McCarthy <pauldmccarthy@gmail.com>
#

TEMP  voxCoord;
TEMP  voxClipLo;
TEMP  voxClipHi;
TEMP  voxValue;
TEMP  posColour;
TEMP  negColour;
TEMP  useNegCmap;
TEMP  negVoxValue;

PARAM imageShape = program.local[4];
PARAM clipping   = program.local[5];
PARAM negCmap    = program.local[6];
  
# This matrix scales the voxel value to
# lie in a range which is appropriate to
# the current display range 
PARAM voxValXform[4] = { program.local[0],
                         program.local[1],
                         program.local[2],
                         program.local[3] };

# retrieve the voxel coordinates,
# bail if they are are out of bounds  
MOV voxCoord, fragment.texcoord[1];

#pragma include test_in_bounds.prog

# look up image voxel value
# from 3D image texture
TEX voxValue.x, fragment.texcoord[0], texture[0], 3D;

# Figure out which negative colour map
# should be used for this fragment.
# We use the negative colour map ...
# 
# if the voxel value is less than
# texZero (the display range centre),
SLT useNegCmap.x, voxValue.x, negCmap.y;

# and the negative colour map is active.
# The useNegCmap vector will be negative
# if both of these conditions are true,
# positive otherwise.
MUL useNegCmap.x, useNegCmap.x, negCmap.x;
SUB useNegCmap.x, useNegCmap.x, 0.5;
MUL useNegCmap.x, useNegCmap.x, -1;

# If using the negative colour map,
# we need to flip the voxel value about
# the display range centre.

# Calculate the inverted voxel value
ADD negVoxValue.x, negCmap.y,     negCmap.y;
SUB negVoxValue.x, negVoxValue.x, voxValue.x;

# If we're using the negative colour
# map, replace the original voxel
# value with the inverted one.
CMP voxValue.x, useNegCmap.x, negVoxValue.x, voxValue.x;

# Test the low clipping range
SUB voxClipLo, voxValue.x, clipping.x;

# And the high clipping range
SUB voxClipHi, voxValue.x, clipping.y;

# Multiply the low/high results - after
# this, voxClipLo will be positive if
# the value is outside of the clipping
# range, or negative if the value is
# within the clipping range
MUL voxClipLo, voxClipLo, voxClipHi;

# Multiply by the clipping.z setting -
# this will invert the sign if normal
# clipping is active
MUL voxClipLo, voxClipLo, clipping.z;

# If the voxel value is outside 
# the clipping range (or inside,
# if clipping is inverted), don't
# draw it
KIL voxClipLo;

# Scale voxel value according
# to the current display range
MAD voxValue, voxValue, voxValXform[0].x, voxValXform[3].x;

# look up the appropriate colour
# in the 1D colour map texture
TEX posColour, voxValue.x, texture[1], 1D;
TEX negColour, voxValue.x, texture[2], 1D;

# useNegCmap is negative if the
# negative colour map should be
# used, positive otherwise.
CMP result.color, useNegCmap.x, negColour, posColour;

END
