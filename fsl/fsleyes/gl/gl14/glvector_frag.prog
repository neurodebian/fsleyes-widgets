!!ARBfp1.0
#
# Fragment program used for rendering GLVector instances, where
# the vector orientation is represented by a combination of RGB colours.
#
# This fragment program does the following:
# 
#  - Retrieves the voxel coordinates corresponding to the fragment
# 
#  - Uses those voxel coordinates to look up the corresponding xyz
#    directions value in the 3D RGB image texture.
#
#  - Looks up the colours corresponding to those xyz directions.
#
#  - Modulates those colours by the modulation texture.
#
#  - Uses those voxel values to colour the fragment.
#
# Required inputs:
# 
#   fragment.texcoord[0] - Fragment texture coordinates
#   fragment.texcoord[1] - Fragment voxel coordinates 
#
#   program.local[0]
#   program.local[1]
#   program.local[2]
#   program.local[3] - Transformation matrix which transforms the vector
#                      image voxel values from their texture value
#                      to the original data range.
#
#   program.local[4]
#   program.local[5]
#   program.local[6]
#   program.local[7] - Transformation matrix which transforms the vector
#                      image voxel values from their data values
#                      to a value which can be used as texture coordinates
#                      for the colour map textures.
#
#   program.local[8] - Image shape - number of voxels along the xyz
#                      dimensions in the image
#
#   program.local[9] - Clipping thresholds. The (x) component contains
#                      the low clipping threshold, and the (y) component
#                      contains the high threshold.
#
# Outputs:
#
#   result.color     - The fragment colour.
#
# Author: Paul McCarthy <pauldmccarthy@gmail.com>
#

TEMP  voxCoord;
TEMP  clipValue;
TEMP  modValue;
TEMP  voxValue;
TEMP  xColour;
TEMP  yColour;
TEMP  zColour;
TEMP  fragColour;
TEMP  clipLow;
TEMP  clipHigh;
PARAM voxValXform[4] = {{ param4_voxValXform }};
PARAM cmapXform[4]   = {{ param4_cmapXform   }};
PARAM imageShape     = {{ param_imageShape   }};
PARAM clipping       = {{ param_clipping     }};

# retrieve the voxel coordinates 
MOV voxCoord, {{ varying_voxCoord }};

# Bail if the voxel coordinate
# is out of the image space
#pragma include test_in_bounds.prog

# look up vector, modulation, and clipping
# values from the three 3D textures.
TEX voxValue,  {{ varying_texCoord }}, {{ texture_vectorTexture   }}, 3D;
TEX modValue,  {{ varying_texCoord }}, {{ texture_modulateTexture }}, 3D;
TEX clipValue, {{ varying_texCoord }}, {{ texture_clipTexture     }}, 3D;

# If the clipping value is
# below the low clipping
# range, or abvve the high
# clipping range, kill the
# fragment.
SUB clipLow,  clipValue.x, clipping.x;
SUB clipHigh, clipping.y,  clipValue.x;

KIL clipLow;
KIL clipHigh;

# Transform vector values from their normalised 
# texture range to their original data range,
# and take the absolue value
MAD voxValue, voxValue, voxValXform[0].x, voxValXform[3].x;
ABS voxValue, voxValue;
MAD voxValue, voxValue, cmapXform[  0].x, cmapXform[  3].x;

# Apply the modulation value
MUL voxValue, voxValue, modValue.x;

# Use the vector values to look up the
# colours for each xyz direction
TEX xColour, voxValue.x, {{ texture_xColourTexture }}, 1D;
TEX yColour, voxValue.y, {{ texture_yColourTexture }}, 1D;
TEX zColour, voxValue.z, {{ texture_zColourTexture }}, 1D;

# Cumulatively combine the rgb
# channels of those three colours
MOV fragColour,             xColour;
ADD fragColour, fragColour, yColour;
ADD fragColour, fragColour, zColour;

# Take the highest alpha of the three colour maps
MAX fragColour.a, xColour.a,    yColour.a;
MAX fragColour.a, fragColour.a, zColour.a;

# Colour the pixel!
MOV result.color, fragColour;

END

